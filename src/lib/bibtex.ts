import { ClassifiedArticle } from '@/types/article';

/**
 * Gera um identificador único para uma entrada BibTeX baseado no título do artigo
 */
function generateBibKey(title: string, index: number): string {
  // Remove caracteres especiais e espaços, pega as primeiras palavras para o identificador
  const cleanTitle = title
    .toLowerCase()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, '_')
    .split('_')
    .slice(0, 3)
    .join('_');
  
  // Adiciona o ano atual e um índice para evitar duplicações
  const year = new Date().getFullYear();
  return `${cleanTitle}_${year}_${index}`;
}

/**
 * Escapa caracteres especiais para o formato BibTeX
 */
function escapeBibtex(text: string): string {
  return text
    .replace(/{/g, '\\{')
    .replace(/}/g, '\\}')
    .replace(/\\/g, '\\textbackslash{}')
    .replace(/&/g, '\\&')
    .replace(/%/g, '\\%')
    .replace(/\$/g, '\\$')
    .replace(/#/g, '\\#')
    .replace(/_/g, '\\_')
    .replace(/~/g, '\\~{}')
    .replace(/\^/g, '\\^{}')
    .replace(/\s+/g, ' ');
}

/**
 * Extrai o ano da fonte ou de outras propriedades disponíveis
 */
function extractYear(article: ClassifiedArticle): string {
  // Tentar extrair o ano da fonte ou de dados originais
  if (article.originalData) {
    if (article.originalData.year) return article.originalData.year.toString();
    if (article.originalData.date) {
      const yearMatch = article.originalData.date.toString().match(/\b(19|20)\d{2}\b/);
      if (yearMatch) return yearMatch[0];
    }
  }
  
  // Tentar extrair o ano da string da fonte
  if (article.source) {
    const yearMatch = article.source.match(/\b(19|20)\d{2}\b/);
    if (yearMatch) return yearMatch[0];
  }
  
  // Se não encontrar, usar o ano atual
  return new Date().getFullYear().toString();
}

/**
 * Extrai autores dos dados originais ou usa 'Unknown' se não disponível
 */
function extractAuthors(article: ClassifiedArticle): string {
  if (article.originalData && article.originalData.authors) {
    return article.originalData.authors.toString();
  }
  
  if (article.originalData && article.originalData.author) {
    return article.originalData.author.toString();
  }
  
  return "Unknown";
}

/**
 * Extrai o nome do journal/conferência ou usa 'Unknown' se não disponível
 */
function extractJournal(article: ClassifiedArticle): string {
  if (article.source) return article.source;
  
  if (article.originalData) {
    if (article.originalData.journal) return article.originalData.journal.toString();
    if (article.originalData.conference) return article.originalData.conference.toString();
    if (article.originalData.booktitle) return article.originalData.booktitle.toString();
    if (article.originalData.venue) return article.originalData.venue.toString();
  }
  
  return "Unknown";
}

/**
 * Gera um arquivo BibTeX a partir dos artigos classificados como incluídos
 */
export function generateBibTeX(articles: ClassifiedArticle[]): string {
  // Filtra apenas os artigos marcados como "include"
  const includedArticles = articles.filter(article => article.classification.include);
  
  if (includedArticles.length === 0) {
    return "% No articles were included in the classification.";
  }
  
  // Gerar entradas BibTeX para cada artigo incluído
  const bibtexEntries = includedArticles.map((article, index) => {
    const bibKey = generateBibKey(article.title, index + 1);
    const title = escapeBibtex(article.title);
    const authors = escapeBibtex(extractAuthors(article));
    const year = extractYear(article);
    const journal = escapeBibtex(extractJournal(article));
    const abstract = escapeBibtex(article.abstract);
    const doi = article.doi || "";
    
    return `@article{${bibKey},
  title = {${title}},
  author = {${authors}},
  journal = {${journal}},
  year = {${year}},
  abstract = {${abstract}}${doi ? `,
  doi = {${doi}}` : ''}
}`;
  });
  
  // Adicionar um cabeçalho com informações sobre a exportação
  const header = `% BibTeX file generated by ScreHelper
% Date: ${new Date().toISOString().split('T')[0]}
% Includes ${includedArticles.length} articles classified for inclusion

`;
  
  return header + bibtexEntries.join("\n\n");
}

/**
 * Cria e faz o download de um arquivo BibTeX
 */
export function downloadBibTeX(articles: ClassifiedArticle[]): void {
  const bibtexContent = generateBibTeX(articles);
  const blob = new Blob([bibtexContent], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `included_articles_${new Date().toISOString().split('T')[0]}.bib`;
  document.body.appendChild(a);
  a.click();
  
  // Limpar
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}
